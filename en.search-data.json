{"/about/":{"data":{"":"","bibliography#Bibliography":"","experiences#Experiences":"Bibliography Homepage https://github.com/hftsin\nSkills Experiences ","homepage#Homepage":"","skills#Skills":""},"title":"About Me"},"/posts/understanding-value-categories-in-modern-c-/":{"data":{"":"","evolution-of-value-categories#Evolution of Value Categories":"The evolution of value categories in C++ reflects the language’s growth in handling efficient resource management and perfect forwarding.\ntimeline title C++ Value Categories Evolution Timeline section Classic Era 1983 : C++ Initial Release : Only lvalue and rvalue 1998 : C++98 Standard : Maintained simple model section Modern Era 2011 : C++11 Revolution : Added xvalue category : Introduced move semantics : Rvalue references 2017 : C++17 Changes : Guaranteed copy elision : Mandatory RVO : Better prvalue handling 2020 : C++20 Refinements : Property-based model : Enhanced template rulesPre-C++11 In traditional C++ (pre C++11), there were only two value categories:\nlvalue: Expressions that refer to a memory location rvalue: Everything else (temporaries, literals) This simple model worked well until the need for move semantics became apparent.\nC++11 Revolution C++11 introduced a more refined system with five value categories:\nPrimary categories: lvalue, xvalue, prvalue Combined categories: glvalue (generalized lvalue), rvalue This change was driven by:\nIntroduction of move semantics Need for perfect forwarding Rvalue references (Type\u0026\u0026) C++17 Guaranteed Copy Elision C++17 further refined the model by:\nGuaranteeing copy elision in certain cases Materializing temporary objects differently Clarifying prvalue materialization Modern Understanding (C++20 and beyond) The current model emphasizes:\nProperties over categories Has Identity Can Be Moved From Direct interaction with: Reference qualifiers Template argument deduction Overload resolution ","introduction#Introduction":"Value categories in C++ are fundamental concepts that classify expressions based on their properties. Understanding value categories is essential and crucial for modern C++ programming, especially when working with performance optimization through move semantics and perfect forwarding.","references#References":" Ben Saks. Back to Basics: Understanding Value Categories. CppCon 2019 ","understanding-value-categories#Understanding Value Categories":"Basic Concepts Prior to modern C++, the values of expression can be roughly categories into lvalue and rvalue by the relative position of value to the assignment operator. Lvalue appears on the left side of assignment while Rvalue is on the right end.\nSince C++11, to support the introduction of move semantics, the value categories are refined through two fundamental properties:\nHas Identity: Can the object be identified (i.e., located in memory, addressed, persists across statements) Can Be Moved From: Can the object’s resources be transferred to another object Value that has identity is generalized left value (glvalue), while values that can be moved from are right values (rvalue). Glvalue contains lvalue and xvalue (expiring value), Rvalue contains pvalue and xvalue.\nCategory Has Identity Can Be Moved From Example lvalue ✅ Yes ❌ No x, *p, arr[0] xvalue ✅ Yes ✅ Yes std::move(x), arr[0] prvalue ❌ No ✅ Yes 42, x + y Examples // lvalue examples int x = 42; // x is lvalue int\u0026 ref = x; // ref is lvalue int arr[10]; // arr is lvalue std::string str; // str is lvalue // prvalue examples int getValue() { return 42; // 42 is prvalue } auto lambda = [](){}; // lambda expression is prvalue 1 + 2; // arithmetic result is prvalue // xvalue examples std::move(x); // result is xvalue std::string().substr() // temporary object from member function static_cast\u003cint\u0026\u0026\u003e(x) // cast to rvalue reference // Understanding combined categories: struct S { int m; }; S().m; // member of prvalue: xvalue std::move(x).m; // member of xvalue: xvalue "},"title":"Understanding Value Categories in Modern C++"},"/tutorials/tmux-cheat-sheet/":{"data":{"":" tmux is a terminal multiplexier.","configurations#Configurations":"","key-bindings#Key bindings":"Each key binding in tmux belongs to a named key table. There are four default key tables:\nroot: contains key bindings for keys pressed without the prefix key, prefix: contains key bindings for keys pressed after the prefix key, copy-mode: contains key bindings for keys used in copy mode with emacs-style keys, and copy-mode-vi: contains key bindings for keys used in copy mode with vi-style keys. The default prefix is C-b, and the 2nd prefix is C-a which is GNU screen compatible.\nShow key bindings by runningtmux lsk.\nKey Description ? List key bindings e Open local config copy with editor defined by EDIDOR env var r Reload config C-c Create a new session s Select a new session for the attached client interactively ( Switch the attached client to the previous session ) Switch the attached client to the next session $ Rename current session c Create a new window \u0026 Kill current window , Rename current window w Choose the current window interactively (across sessions) ' Prompt an window index to select . Prompt an window index to move - Split window horizontally % Split window vertically o Rotate among panels in current window ! Make current panel to a new window x Kill current panel m Toggle mouse on/off I Install plugin alt + u Uninstall plugin U Update plugin ","references#References":" Tmux Cheat Sheet \u0026 Quick Reference Awesome Tmux ","terminal-hierarchy#Terminal Hierarchy":"session -\u003e window -\u003e panel"},"title":"Tmux Cheat Sheet"}}