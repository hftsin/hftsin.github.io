{"/about/":{"data":{"":"","bibliography#Bibliography":"","experiences#Experiences":"Bibliography Homepage https://github.com/hftsin\nSkills Experiences ","homepage#Homepage":"","skills#Skills":""},"title":"About Me"},"/posts/understanding-value-categories-in-modern-c-/":{"data":{"":"","evolution-of-value-categories#Evolution of Value Categories":"The evolution of value categories in C++ reflects the language’s growth in handling efficient resource management and perfect forwarding.\ntimeline title C++ Value Categories Evolution Timeline section Classic Era 1983 : C++ Initial Release : Only lvalue and rvalue 1998 : C++98 Standard : Maintained simple model section Modern Era 2011 : C++11 Revolution : Added xvalue category : Introduced move semantics : Rvalue references 2017 : C++17 Changes : Guaranteed copy elision : Mandatory RVO : Better prvalue handling 2020 : C++20 Refinements : Property-based model : Enhanced template rulesPre-C++11 In traditional C++ (pre C++11), there were only two value categories:\nlvalue: Expressions that refer to a memory location rvalue: Everything else (temporaries, literals) This simple model worked well until the need for move semantics became apparent.\nC++11 Revolution C++11 introduced a more refined system with five value categories:\nPrimary categories: lvalue, xvalue, prvalue Combined categories: glvalue (generalized lvalue), rvalue This change was driven by:\nIntroduction of move semantics Need for perfect forwarding Rvalue references (Type\u0026\u0026) C++17 Guaranteed Copy Elision C++17 further refined the model by:\nGuaranteeing copy elision in certain cases Materializing temporary objects differently Clarifying prvalue materialization Modern Understanding (C++20 and beyond) The current model emphasizes:\nProperties over categories Has Identity Can Be Moved From Direct interaction with: Reference qualifiers Template argument deduction Overload resolution ","introduction#Introduction":"Value categories in C++ are fundamental concepts that classify expressions based on their properties. Understanding value categories is essential and crucial for modern C++ programming, especially when working with performance optimization through move semantics and perfect forwarding.","references#References":" Ben Saks. Back to Basics: Understanding Value Categories. CppCon 2019 ","understanding-value-categories#Understanding Value Categories":"Basic Concepts Prior to modern C++, the values of expression can be roughly categories into lvalue and rvalue by the relative position of value to the assignment operator. Lvalue appears on the left side of assignment while Rvalue is on the right end.\nSince C++11, to support the introduction of move semantics, the value categories are refined through two fundamental properties:\nHas Identity: Can the object be identified (i.e., located in memory, addressed, persists across statements) Can Be Moved From: Can the object’s resources be transferred to another object Value that has identity is generalized left value (glvalue), while values that can be moved from are right values (rvalue). Glvalue contains lvalue and xvalue (expiring value), Rvalue contains pvalue and xvalue.\nCategory Has Identity Can Be Moved From Example lvalue ✅ Yes ❌ No x, *p, arr[0] xvalue ✅ Yes ✅ Yes std::move(x), arr[0] prvalue ❌ No ✅ Yes 42, x + y Examples // lvalue examples int x = 42; // x is lvalue int\u0026 ref = x; // ref is lvalue int arr[10]; // arr is lvalue std::string str; // str is lvalue // prvalue examples int getValue() { return 42; // 42 is prvalue } auto lambda = [](){}; // lambda expression is prvalue 1 + 2; // arithmetic result is prvalue // xvalue examples std::move(x); // result is xvalue std::string().substr() // temporary object from member function static_cast\u003cint\u0026\u0026\u003e(x) // cast to rvalue reference // Understanding combined categories: struct S { int m; }; S().m; // member of prvalue: xvalue std::move(x).m; // member of xvalue: xvalue "},"title":"Understanding Value Categories in Modern C++"}}